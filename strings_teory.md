**Вопрос 1.**  
Что появится в консоли в результате работы фрагмента программы?  
``` java
String a = "java";
a.toUpperCase();
System.out.println(a);
```
**Ответ:** java  
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/manipstrings.html
***
**Вопрос 2.**  
Что появится в консоли в результате работы фрагмента программы?  
``` java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
System.out.println("s1 == s2 : " + (s1 == s2));
System.out.println("s1 == s3 : " + (s1 == s3));
System.out.println(s1.equals(s3));
```
Поясните ответ.  
**Ответ:** Благодаря неизменности Strings в Java, JVM может оптимизировать объем памяти, выделенный для них, сохраняя только одну копию каждого литерала String в пуле . Этот процесс называется interning.  
В нашем случае, при инициализации s1, строка "Java" будет занесена в пул литералов. При инициализации s2 будет произведен поиск строки "Java" в пуле и т.к. она там уже имеется, s2 будет присвоен адрес первоначального внесенного литерала, на который также сcылается s1. Когда мы создаем s3 с помощью оператора new, компилятор Java создает новый объект и сохраняет его в пространстве кучи, зарезервированном для JVM.
Каждая строка String , созданная таким образом, будет указывать на другую область памяти со своим собственным адресом.  
На основании вышесказанного, в результате работы заданного фрагмента программы, будет выведено:
``` java
s1 == s2 : true
s1 == s3 : false
true
```
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/strings.html  
https://www.codeflow.site/ru/article/java-string-pool  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 174
***
**Вопрос 3.**  
Можно ли выполнить наследование от класса String?  
Почему?  
**Ответ:** Нет, т.к. класс String объявлен с модификатором final, который как мы знаем запрещает наследование.  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/lang/String.html  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 170
***
**Вопрос 4.**  
Назовите основные, на ваш взгляд, методы класса String.  
**Ответ:**  
`boolean equals(Object ob)` - сравнение строк с учетом и без учета регистра соответственно;  
`int length()` — определение длины строки;  
`String toUpperCase()/toLowerCase()` — преобразование всех символов вызывающей строки в верхний/нижний регистр;  
`String trim()` — удаление всех пробелов в начале и конце строки;  
`static String format(String format, Object… args), format(Locale l, String 
format, Object… args)` — генерирует форматированную строку, полученную с использованием формата, интернационализации и др.;  
`String[] split(String regex), String[] split(String regex, int limit)` — поиск вхождения в строку заданного регулярного выражения (разделителя) и деление исходной строки в соответствии с этим на массив строк.  
`String substring(int n, int m)` — извлечение из строки подстроки длины m-n, начиная с позиции n. Нумерация символов в строке начинается с нуля;  
`int indexOf(String str)` — определение позиции первого вхождения подстроки в строке;  
`static String valueOf(значение)` — преобразование переменной базового типа к строке;  
`String replace(char с1, char с2)` — замена в строке всех вхождений первого символа вторым символом;  
`matches(String regex)` - Сообщает, соответствует ли эта строка заданному регулярному выражению;  
`hashCode()` -Возвращает хэш-код для этой строки.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 171  
https://docs.oracle.com/javase/8/docs/api/java/lang/String.html
***
**Вопрос 5.**  
Какие разновидности конструкторов использует класс String?  
**Ответ:** Класс String поддерживает следующие разновидности конструкторов: String(), String(String  str),  String(byte[]  asciichar),  String(char[]  unicodechar), String(StringBuffer sbuf), String(StringBuilder sbuild) и др. Эти конструкторы используются для создания объектов класса String на основе инициализации значениями из массива типа char, byte и др.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 170
***
**Вопрос 6.**  
Какие классы в стандартной библиотеке Java работают со строками?  
**Ответ:** Системная библиотека Java содержит классы String, StringBuilderи StringBuffer, поддерживающие работу со строками и определенные в пакете java.lang, подключаемом автоматически.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 170
***
**Вопрос 7.**  
Почему экземпляры класса String в Java неизменные и финализированные?  
**Ответ:** Ключевыми преимуществами сохранения этого класса как неизменяемого являются кэширование, безопасность, синхронизация и производительность.  
1\) String является наиболее широко используемой структурой данных. Кэширование литералов String и их повторное использование экономит много места в куче, поскольку разные переменные String ссылаются на один и тот же объект в пуле String . String intern pool служит именно для этой цели.  
2\) String широко используется в приложениях Java для хранения конфиденциальных данных, таких как имена пользователей, пароли, URL-адреса подключений, сетевые подключения и т. Д. Он также широко используется загрузчиками классов JVM при загрузке классов.  
Следовательно, защита класса String имеет решающее значение для безопасности всего приложения в целом.  
3\) Возможность неизменности автоматически делает поток String безопасным, поскольку они не будут изменены при доступе из нескольких потоков.  
Следовательно, неизменяемые объекты, как правило, могут совместно использоваться несколькими потоками, работающими одновременно. Они также поточнобезопасны , потому что если поток изменяет значение, то вместо его изменения в пуле String будет создана новая String . Следовательно, Strings безопасны для многопоточности.  
4\) Поскольку объекты String широко используются в качестве структуры данных, они также широко используются в реализациях хеширования, таких как HashMap , HashTable , HashSet и т. Д. При работе с этими реализациями хеширования метод hashCode () довольно часто вызывается для группирования.  
Неизменность гарантирует Strings , что их значение не изменится. Поэтому метод hashCode () переопределяется в классе String для упрощения кэширования, так что хэш вычисляется и кэшируется во время первого вызова hashCode () , и с тех пор возвращается одно и то же значение.  
Это, в свою очередь, повышает производительность коллекций, использующих хэш-реализации при работе с объектами String.  
**Источник:** https://www.codeflow.site/ru/article/java-string-immutable  
http://tlazarenko.blogspot.com/2013/10/string-java.html
***
**Вопрос 8.**  
Заполните ячейки таблицы (Да/Нет).  
|Characteristic                 |String    |StringBuilder|StringBuffer|
|:-----------------------------:|:--------:|:-----------:|:----------:|
|Неизменяемый (Immutable)?      |    	   |             |            |
|Имеет пул (Pooled)?	        |    	   |             |            |
|Потокобезопасный (Thread-safe)?|    	   |             |            |
|Может изменять размер?	        |          |             |            |

**Ответ:**  
|Characteristic                 |String    |StringBuilder|StringBuffer|
|:-----------------------------:|:--------:|:-----------:|:----------:|
|Неизменяемый (Immutable)?      |    Да	   |     нет     |     нет    |
|Имеет пул (Pooled)?	        |    Да	   |     нет     |     нет    |
|Потокобезопасный (Thread-safe)?|    Да	   |     нет     |     да     |
|Может изменять размер?	        |    Нет   |      да     |     да     |

**Источник:** https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java  
https://www.codeflow.site/ru/article/thread-pool-java-and-guava
***
**Вопрос 9.**  
В чем разница и что общего между StringBuffer и StringBuilder?  
**Ответ:**  
|                  |StringBuffer  |StringBuilder|
|:----------------:|:------------:|:-----------:|
|Изменяемость      | mutable (да) | mutable (да)|
|Расширяемость     |  final (нет) | final (нет) |
|Потокобезопасность| Да, за счет синхронизации|	Нет|
|Когда использовать| При работе со строками, которые часто будут модифицироваться в многопоточной среде|При работе со строками, которые часто будут модифицироваться, в однопоточной среде|

**Источник:** https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 174  
***
**Вопрос 10.**  
Когда лучше использовать StringBuffer, а когда StringBuilder?  
**Ответ:** При работе со строками, которые часто будут модифицироваться в многопоточной среде лучше использовать StringBuffer, т.к. его методы синхронизированы, а экземпляры могут быть использованы несколькими потоками одновременно. При работе со строками, которые часто будут модифицироваться, в однопоточной среде лучшим выбором является StringBuilder, т.к. его асинхронные методы будут работать быстрее синхронизированных.  
**Источник:** https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 174  
***
**Вопрос 11.**  
Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?  
**Ответ:** Основные методы на которые следует обратить внимание:  
`void setLength(int n)` — установка размера буфера;  
`void ensureCapacity(int minimum)` — установка гарантированного мини-мального размера буфера;  
`int capacity()` — возвращение текущего размера буфера;  
`append(параметры)` — добавление к содержимому объекта строкового представления аргумента, который может быть символом, значени-ем базового типа, массивом и строкой;  
`insert(параметры)` — вставка символа, объекта или строки в указанную позицию;  
`deleteCharAt(int index)` — удаление символа;  
`delete(int start, int end)` — удаление подстроки;  
`reverse()` — обращение содержимого объекта.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 175  
***
**Вопрос 12.** 
Какие методы сравнения строк имеются в строковых классах?  
**Ответ:** В классе String имеется немало методов, предназначенных для сравнения символьных строк или подстрок в них.  Основными на мой взгляд являются:  
`equals(Object anObject)` - Сравнивает эту строку с указанным объектом.  
`equalsIgnoreCase(String anotherString)` - Сравнивает это String с другим String, игнорируя рассмотрение случая.  
`contains(CharSequence s)` - Возвращает true тогда и только тогда, когда эта строка содержит указанную последовательность значений char.  
`contentEquals(CharSequence cs)` - Сравнивает эту строку с указанной CharSequence.  
Для классов StringBuffer и StringBuilder не переопределен метод equals() и hashCode(), т. е. сравнить содержимое двух объектов невозможно, следовательно хэш-коды всех объектов этого типа вычисляются так же, как и для класса Object. При идентичном содержимом у двух экземпляров, размеры буфера каждого могут отличаться, поэтому сравнение на эквивалентность объектов представляется неоднозначным. Но у этих классов можно выделить следующие методы, выполняющие сравнение последовательностей:  
`indexOf(String str)` - Возвращает индекс в этой строке первого вхождения указанной подстроки.  
`indexOf(String str, int fromIndex)` - Возвращает индекс в этой строке первого вхождения указанной подстроки, начиная с указанного индекса.  
`lastIndexOf(String str)` - Возвращает в этой строке индекс самого правого вхождения указанной подстроки.  
`lastIndexOf(String str, int fromIndex)` - Возвращает индекс в этой строке последнего вхождения указанной подстроки.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 173  
https://docs.oracle.com/javase/8/docs/api/java/lang/String.html  
https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html  
https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html  
***
**Вопрос 13.**  
Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом.  
**Ответ:**
``` java
    String str = "101";
    StringBuilder sb = new StringBuilder(str);
    sb.reverse();
    System.out.println(sb.toString().contentEquals(str));
```
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», Глава 7  
***
**Вопрос 14.**  
Что появится в консоли в результате работы фрагмента программы?  
``` java
final String ZA = " за ";
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
String[] monthYear = value.split(ZA)[1].split(" ",3);
System.out.println(Arrays.toString(monthYear));
```
Поясните ответ.  
**Ответ:** В консоль будет выведено:  
``` java
 [январь, 2019, г.]
 ```
Методом  `value.split(ZA)` входная строка "ОТЧЕТ о перевозках пассажиров за январь 2019 г." регулярным выражением “за” разобьется на два элемента массива. Фрагмент кода `[1].split(" ",3)` указывает на то, что первый элемент из полученного массива будет дополнительно разбит регулярным выражением “ “ на последовательность из которой будет возвращено только 3 элемента, которые и будут присвоены переменной monthYear.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 171  
***
**Вопрос 15.**  
Что появится в консоли в результате работы фрагмента программы?  
``` java
String s4 = "1" + 2 + 3;
String s5 = 1 + 2 + "3";
System.out.println(s4);
System.out.println(s5);
```
Поясните ответ.  
**Ответ:**
``` java
123
33
```
Последовательность действий выполняется на основании приоритета операций. Знак “+” выполняет функцию конкатенации, если один из операндов представляет собой строковый тип.  
Для s4 последовательность следующая: строковый литерал “1” будет сцеплен с 2, которая будет приведена автоматически, в результате чего получим новую строку. Она в свою очередь будет сцеплена с автоматически приведенной 3.  
Для s5 последовательность иная: сначала будет выполнено сложение  1 и 2, а уже затем конкатенация с “3”.  
**Источник:** Шилдт Герберт.  “Java  8. Полное руководство; 9-е изд.” : Пер. с  англ.  - М. :  ООО "И.Д. Вильяме", 2015. – c.413-414  
https://docs.oracle.com/javase/7/docs/api/java/lang/String.html  
https://www.examclouds.com/ru/java/java-core-russian/concatenation  
***
**Вопрос 16.**  
Что появится в консоли в результате работы фрагмента программы?  
``` java
String s = "abcde ";
System.out.println(s.trim().length());
System.out.println(s.charAt(4));
System.out.println(s.indexOf('e'));
System.out.println(s.indexOf("de"));
System.out.println(s.substring(2, 4).toUpperCase());
System.out.println(s.replace('a', '1'));
System.out.println(s.contains("DE"));
System.out.println(s.startsWith("a"));
```
Поясните ответ.  
**Ответ:**  
``` java
5	// s.trim().length() – происходит удаление пробелов по краям строки и возвращается ее длина
e	// s.charAt(4) - возвращает символ из позиции 4
4	// s.indexOf('e') – возвращает позицию символа в строке
3	// s.indexOf("de")- возвращает индекс начало вхождения подстроки в строке
CD	// s.substring(2, 4).toUpperCase() – возвращает подстроку из строки начиная со 2 позиции по 4 (не включая) и преобразует к верхнему регистру
1bcde	// s.replace('a', '1') – производит замену в строке всех вхождений первого символа на второй
false	// s.contains("DE") – проверяет, содержит ли исходная строка входную последовательность символов
true	//s.startsWith("a")- проверяет, начинается ли строка с указанного префикса
```
**Источник:** https://docs.oracle.com/javase/7/docs/api/java/lang/String.html  
***
**Вопрос 17.**  
Что появится в консоли в результате работы фрагмента программы?**
``` java
StringBuilder b = new StringBuilder();
b.append(12345).append('-');
System.out.println(b.length());
System.out.println(b.indexOf("-"));
System.out.println(b.charAt(2));
StringBuilder b2 = b.reverse();
System.out.println(b.toString());
System.out.println(b == b2);
```
Поясните ответ.  
**Ответ:**  
``` java
	// b.append(12345).append('-') – создается строка “12345-“
6	// b.length() – возвращает длину строки
5	// b.indexOf("-") – возвращает позицию указанного символа
3	// b.charAt(2) – возвращает символ из позиции 2
	// b2 = b.reverse() – происходит присвоение b2 инверсной последовательности символов
-54321		//b.toString() – возвращает строковое представление данных (в указанном контексте, данная запись избыточна)
True	// b == b2 – возвращает результат сравнения ссылок b и b2 //(true т.к. b и b2 указывают на один и тот же объект //StringBuilder b = new StringBuilder();
	//StringBuilder b2 = b.reverse();)
```
**Источник:** https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html  
***
**Вопрос 18.**
Что появится в консоли в результате работы фрагмента программы?  
``` java
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
```
Поясните ответ.  
**Ответ:**  
``` java
a-bde		// s.insert(1, '-').delete(3, 4) – производится вставка в  строку s ("abcde") символа “-“ в позицию с индексом 1. Затем происходит удаление символов с 3 позиции по 4 (не включая).
вd	// s.substring(2, 4) – возвращает подстроку из строки начиная со 2 позиции по 4 (не включая).
```
**Источник:** https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html  
***
**Вопрос 19.**  
``` java
StringBuffer sb = new StringBuffer("abcde");
sb.insert(2,"123");
sb.append("456");
sb.reverse();
```
Поясните ответ.  
**Ответ:**
``` java 
654edc321ba
```
`StringBuffer sb = new StringBuffer("abcde");` // создается строка  
`sb.insert(2,"123");`	// во вторую позицию строки происходит вставка “123” => ab123cde  
`sb.append("456");`	//происходит добавление к концу строки “456” => ab123cde456  
`sb.reverse();` //инвертируется последовательность символов => 654edc321ba  
**Источник:** https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html  
***
**Вопрос 20.**  
Каким образом можно сцепить строки Java?  
Назовите не менее 3 способов.  
**Ответ:**  
1\) Воспользоваться методом `concat(String str)` - добавляет указанную строку в конец исходной.
2\) использовать символ конкатенации: `+`
3\) Воспользоваться методом  `join (CharSequence  разделитель ,  CharSequence  . . .  строки)` - предназначен для  соединения  двух  и более  символьных  строк,  разграничиваемых указанным разделителем.  /
4\) Использовать метод `append (параметры)` классов StringBuffer и StringBuilder – добавит указанную последовательность в конец исходной строки.  
**Источник:** Шилдт Герберт.  “Java  8. Полное руководство; 9-е изд.” : Пер. с  англ.  - М. :  ООО "И.Д. Вильяме", 2015. – c.473, 484, 487  
https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html  
https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html  
***
**Вопрос 21.**  
Чем отличаются пустая и нулевая строки?  
**Ответ:** Пустая строка - это строка нулевой длины. Нулевая строка -  это просто объявленная, но не проинициализированная строка. С пустой строкой можно производить все те же действия, как и с обычной, вызывать на ней методы, конкатенировать и т.д. На нулевой же строке вызвать метод не возможно, будет ошибка  NullPointerException.  
**Источник:** https://stackoverrun.com/ru/q/3693508  
https://coderoad.ru/2707322/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-null-%D0%B2-Java  
https://javarush.ru/groups/posts/1080-9-vejshey-o-null-v-java
***
**Вопрос 22.**  
В какой кодировке хранятся символы в строке?  
**Ответ:** В Java для хранения  char обычно используется набор символов в Unicode ; т. е. 16-битный блок, который является частью допустимой последовательности UTF-16.  Все строки в Java представлены в UTF-16 . При записи в файл, отправке по сети или в любом другом месте он отправляется с использованием указанного параметра character encoding.  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html   https://coderoad.ru/7019504/%D0%92-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B9-%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D1%82%D1%81%D1%8F-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB-Java  
***
**Вопрос 23.**  
Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder?  
**Ответ:** Класс String реализует интерфейсы: Serializable, CharSequence, Comparable<String>.  
Классы StringBuffer и StringBuilder реализуют интерфейсы: Serializable, Appendable, CharSequence.  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/lang/String.html  
https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html  
https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html  
***
**Вопрос 24.**  
Что такое кодовые точки и кодовые единицы?  
**Ответ:** 
В Java кодовая точка — это код символа из диапазона от 0 до 10FFFF. Термин “кодовая единица” используется для ссылки на 16-битные символы. Символы, имеющие значения, большие, чем FFFF, называются дополнительными.  
**Источник:** https://www.javaspecialists.eu/archive/Issue209-Unicode-Redux-1-of-2.html  
https://ru.qaz.wiki/wiki/Code_point  
http://www.konspektov.net/question/783  
***
**Вопрос 25.**  
Объясните назначение метода `intern()`.  
Что появится в консоли в результате работы фрагмента программы?  
``` java
class GFG {
	public static void main(String[] args) {
		String s1 = new String("GFG");
		String s2 = s1.intern();
		System.out.println(s1 == s2);
		System.out.println(s1.equals(s2));
		String s3 = "GFG";
		System.out.println(s2 == s3);
	}
}
```
Поясните ответ.  
**Ответ:** Метод `intern()` — заносит строку в «пул» литералов и возвращает ее объектную ссылку. Когда метод `intern()` вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом `equals(Object)`, тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и возвращается ссылка на этот объект.  
В результате работы фрагмента программы на консоль будет выведено:  
``` java
false  
true
true
```
В начале происходит инициализация s1 при помощи вызова конструктора String. Затем s2 присваивается ссылка, возвращенная методом `inter()` для строки s1, занесенной в пул строк. Сравнение `s1 == s2` дает результат false, т.к. они ссылаются на разные объекты. Метод `s1.equals(s2)` закономерно выдаст true, т.к. содержимое строк идентично. После происходит объявление и инициализация s3. В результате того, что инициализация производится строкой, а не через вызов конструктора, происходит поиск равной строки в пуле и т.к. она там уже есть, будет возвращена на нее ссылка, на которую уже указывает s2. В результате сравнение `s2 == s3` даст true.  
**Источник:** https://javarush.ru/groups/posts/760-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch2  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 171  
***
**Вопрос 26.**
Как преобразовать строку в число?  
**Ответ:** Для преобразования строки в число необходимо использовать метод parse соответствующего wrapper-класса (например:  Для преобразования строки “123” в Integer, следует вызвать метод `Integer.parseInt("123")`).  
**Источник:** https://javarush.ru/groups/posts/1948-objertki-raspakovka-i-zapakovka  
***
**Вопрос 27.**  
Какой метод вызывается для преобразования переменной в строку?  
**Ответ:** Метод valueOf(значение) — преобразование переменной базового типа к строке.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 171  
***
**Вопрос 28.**  
Каким методом в классе String можно проверить строку на соответствие регулярному выражению?  
**Ответ:** Методом `matches(String regex)` – он сообщает, соответствует ли эта строка заданному регулярному выражению .  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/lang/String.html  
***
**Вопрос 29.**  
Создайте класс с полями: int, long, float и double, String.  
Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.  
**Ответ:** 
``` java
public class Example {
    int int0 = 0;
    long  long0 = 1;
    float float0 = 2;
    double double0 = 3;
    String str = "str";

    @Override
    public String toString() {
        return String.format("Float: %3$f, Integer: %1$d, Long: %2$d, String: %5$s, Double: %4$e"
                , int0, long0, float0, double0, str );
    }
}
// out
Float: 2,000000, Integer: 0, Long: 1, String: str, Double: 3,000000e+00
```
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html  
***
**Вопрос 30.**  
Опишите:  
\-	назначение класса Formatter,   
\-	методы format(),  
\-	спецификаторы формата.  
**Ответ:** Для  создания форматированного текстового вывода предназначен класс 
java.util.Formatter. Этот класс обеспечивает преобразование формата, позволяющее выводить числа, строки, время и даты в любом необходимом разработчику виде.  
Методы:  
`close()` - закрывает вызывающий объект класса Formatter.  
`void flush()` - очищает Formatter.  
`Formatter	format(Locale l, String format, Object... args)` - записывает форматированную строку в место назначения этого объекта, используя указанный языковой стандарт, строку формата и аргументы.  
`Formatter	format(String format, Object... args)` - записывает отформатированную строку в место назначения этого объекта, используя указанную строку формата и аргументы.  
`IOException	ioException()`- возвращает IOException последнее значение, созданное этим средством форматирования Appendable.  
`Locale	locale()` - возвращает региональные установки вызывающего объекта.  
`Appendable	out()` - возвращает место назначения для вывода.  
`String	toString()` - возвращает результат вызова `toString()` в место назначения вывода.  
|Спецификатор  формата|Выполняемое форматирование|
|:-------------------:|:------------------------:|
|%a| Шестнадцатеричное значение с плавающей точкой|
|%b| Логическое (булево) значение аргумента|
|%c| Символьное представление аргумента|
|%d| Десятичное целое значение аргумента|
|%h| Хэш-код аргумента|
|%e| Экспоненциальное представление аргумента|
|%f| Десятичное значение с плавающей точкой|
|%g| Выбирает более короткое представление из двух: %еили %f|
|%o| Восьмеричное целое значение аргумента|
|%n| Вставка символа новой строки|
|%s| Строковое представление аргумента|
|%t| Время и дата|
|%x| Шестнадцатеричное целое значение аргумента|
|%%| Вставка знака %|

**Источник:** https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 189  
***
**Вопрос 31.**  
Что представляет собой регулярное выражение?  
На каких классах базируются regex-возможности языка Java?  
В каком пакете эти классы расположены?  
**Ответ:** Регулярное выражение (RegEx) – это шаблон для поиска строки в тексте.
Regex- возможности языка Java базируется на классах Pattern и Matcher. Эти классы действуют совместно.  Регулярное выражение определяется в  классе Pattern, а  сопоставление последовательности  символов  с  шаблоном осуществляется средствами класса Matcher. Эти классы расположены в пакете  java.util.regex  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 177  
Шилдт Герберт.  “Java  8. Полное руководство; 9-е изд.” : Пер. с  англ.  - М. :  ООО "И.Д. Вильяме", 2015. – c.1092  
https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java  
***
**Вопрос 32.**  
Опишите назначение классов Pattern и Matcher.  
Каким образом они связываются?  
Предоставить простейший код их взаимодействия.  
**Ответ:** Класс Pattern применяется для определения регулярных выражений (шаблонов), для которых ищется соответствие в строке, файле или другом объекте, представляющем последовательность символов. Для определения шаблона применяются специальные синтаксические конструкции. Сопоставление последовательности символов с шаблоном осуществляется средствами класса Matcher. Эти классы действуют совместно. 
В классе Pattern конструкторы не определяются. Вместо этого для составления шаблона вызывается фабричный метод `compile ()`. Ниже приведена одна из общих форм этого метода.  
``` java
static Pattern compile  (String  шаблон)  
```
Здесь параметр шаблон обозначает регулярное выражение, которое требуется использовать.  Метод `compile ()` преобразует в шаблон символьную строку, определяемую параметром шаблон, для сопоставления средствами класса Matcher. Этот метод возвращает объект типа Pattern, содержащий шаблон. Как только объект типа Раttеrn будет получен, его можно использовать для создания объекта типа Маtcher.  Для этого вызывается фабричный метод `matcher ()`, определяемый в классе Pattern. Ниже приведена его общая форма.  
``` java
Мatcher matcher ( CharSequence  строка)  
```
Здесь параметр строка обозначает последовательность символов, сопоставляемую  с  шаблоном  и  называемую  входной  последовательностью. Как только объект класса Matcher будет создан, его методы можно использовать для выполнения различных операций сопоставления с шаблоном. Самым простым для сопоставления с шаблоном является метод `matches ()`, который просто определяет, совпадает ли последовательность символов с шаблоном.  
Пример кода взаимодействия этих классов:  
``` java
Pattern p1 = Pattern.compile("a+y");
Matcher m1 = p1.matcher("aaay");
Boolean b = m1.matches();
System.out.println(b);
// Out true
```
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 177-178  
Шилдт Герберт.  “Java  8. Полное руководство; 9-е изд.” : Пер. с  англ.  - М. :  ООО "И.Д. Вильяме", 2015. – c.1092-1093  
 https://habr.com/ru/post/260773/  
***
**Вопрос 33.**  
При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте href.  
**Ответ:** 
``` java
    String regex = "href=\"(.*?)\"";
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(webPage);
    System.out.println("Найденные совпадения:");
    while(matcher.find()) {
        System.out.println(matcher.group(1));
    }
```
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 177-178  
***
**Вопрос 34.**  
Какой из способов сравнения строк предпочтительнее?  
``` java
str.equals("abc");
```
или
``` java
"abc".equals(str);
```
Поясните ответ.  
**Ответ:** Предпочтительнее использовать ```"abc".equals(str)```, т.к. в таком случае исключается возможность вызова метода у не проинициализированной строки null, что может привести к ошибке NullPointerException.  
**Источник:** https://javarush.ru/groups/posts/1080-9-vejshey-o-null-v-java  
https://coderoad.ru/513832/%D0%9A%D0%B0%D0%BA-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D1%8C-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D0%B2-Java  
***
**Вопрос 35.**  
Как сравнить объекты StringBuilder и StringBuffer?  
**Ответ:** Для классов StringBuffer и StringBuilder не переопределены методы `equals()` и `hashCode()`, т. е. сравнить содержимое двух объектов невозможно, следовательно хэш-коды всех объектов этого типа вычисляются так же, как и для класса Object. При идентичном содержимом у двух экземпляров, размеры буфера каждого могут отличаться, поэтому сравнение на эквивалентность объектов представляется неоднозначным.  
Сравнить содержимое можно следующим образом:  
``` java
StringBuffer sb1 = newStringBuffer();
StringBuffer sb2 = newStringBuffer();
sb1.toString().contentEquals(sb2)
```
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 176-177  
***
**Вопрос 36.**  
Что появится в консоли в результате работы фрагмента программы? 
``` java
System.out.printf(
	"%d студентов пришли сдавать зачет по %8.10s, \n" 
	+ "из них не сдали %d, %s", 
	10, "J2SE", 5, "а остальные сдали на отлично"
);
```
Поясните ответ.  
**Ответ:** В результате работы фрагмента программы в консоль будет выведено:
``` java
10 студентов пришли сдавать зачет по J2SE,
из них не сдали 5, а остальные сдали на отлично
```
Здесь используется форматированный вывод строки при помощи метода `printf()`. Сначала указывается строка с расставленными внутри нее спецификаторами, а следом идут подставляемые аргументы. Первый `%d` указывает на то, что сюда будет подставлен первый аргумент, представляющий собой десятичное число. `%8.10s` заменится строкой, длинна которой не менее 8 и не более 10 символов, следующего аргументы. Затем при помощи `\n` осуществляется перенос на новую строку. Следующий спецификатор `%d` заменится десятичном числом третьего аргумента, а `%s` подставит строку последнего.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 189-193  
***
**Вопрос 37.**  
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".  
**Ответ:**  
``` java
regex = "http[s]?.*?by"  
```
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 177-178  
***
**Вопрос 38.**  
Сформировать регулярное выражение, при помощи которого можно выбрать все значения URL-запроса с ресурса https://bsut.by.  
Например, запрос https://bsut.by?value1=5&value2=10&iscan=true.  
Вывод  
``` java
value1=5
value2=10
iscan=true
```
**Ответ:**  
``` java
regex = "\\w*=\\w*" 
```
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html  
***
**Вопрос 39.**  
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.  
**Ответ:** Вот небольшой список базовых конструкций регулярных выражений.  
Символы  
|||
|:-:|:-|
|. |(точка) — соответствует любому одиночному символу за исключением переноса строки.|
|* | соответствует предыдущему выражению, которое повторено 0 или более раз.| 
|+ | соответствует предыдущему выражению, которое повторено 1 или более раз.|
|? | соответствует предыдущему выражению, повторённому 0 или 1 раз.| 
|^ | соответствует началу строки.|
|$ | соответствует концу строки.|

Кроме стандартных классов символов существуют предопределенные классы символов:  
|||
|:-:|:-|
|. | любой символ|
|\d | или \p{Digit} [0-9]|
|\D | [^0-9]|
|\s или \p{Space} |  [ \t\n\x0B\f\r]|
|\S | [^\s]|  
|\w | [0-9_A-Za-z]|
|\W | [^\w]|
|\p{Lower}| [a-z]|
|\p{Upper}| [A-Z]|
|\p{Punkt}|!"#$%&'()*+,-./:;<=>?@[\\]^_\`{|}~|
|\p{Blank}| Пробел или табуляция|

Основные логические конструкции  
|||
|:-:|:-|
|[abc]| a, bили c|
|[^abc]| символ, исключая a, b и c|
|[a-z]| символ между a и z|
|[a-d[m-p]]| между aи d, или между m и p|

При создании регулярного выражения могут использоваться логические 
операции:  
|||
|:-:|:-|
|ab   | после aследует b|
|a\|b | a либо b|
|(a)  | а|

Скобки кроме их логического назначения также используются для выделения групп. Они имеют такой же смысл, как в математических выражениях; они группируют вместе выражения, содержащиеся в них, в результате чего можно повторять содержание группы повторяющими квалификаторами, такими как *, +, ? и {m, n}.  
Для определения регулярных выражений недостаточно одних классов символов, т. к. в шаблоне часто нужно указать количество повторений. Для этого существуют квантификаторы.  
|||
|:-:|:-|
|a?| a один раз или ни разу|
|a*| a ноль или более раз|
|a+| a один или более раз|
|a{n}|  a n раз|
|a{n,}| a n или более раз|
|a{n,m}| a от n до m|

Существует еще два типа квантификаторов, которые образованы прибавлением суффикса «?» (слабое или неполное совпадение) или «+» («жадное» или собственное совпадение) к вышеперечисленным квантификаторам. Неполное совпадение соответствует выбору с наименее возможным количеством симво-лов, а собственное — с максимально возможным.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 177-181  
***
**Вопрос 40.**  
Назовите основные, на ваш взгляд, методы класса Pattern.  
**Ответ:** 
`Pattern compile(String regex)` — возвращает Pattern, который соответству-ет regex;  
`boolean matches(String regex, CharSequence input)` — проверяет на соот-ветствие строки inputшаблону regex;  
`String[] split(CharSequence input)` — разбивает строку input, учитывая, что 
разделителем является шаблон;  
`Matcher matcher(CharSequence input)` — возвращает Matcher, с помощью 
которого можно находить соответствия в строке input.  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 178-179  
***
**Вопрос 41.**  
Назовите основные, на ваш взгляд, методы класса Matcher.  
**Ответ:**  
`boolean matches()` — проверяет, соответствует ли вся информация шаблону;  
`boolean lookingAt()` — поиск последовательности символов, начинающейся 
с начала строки и соответствующей шаблону;  
`boolean find()или boolean find(int start)` — ищет последовательность сим-волов, соответствующих шаблону, в любом месте строки. Параметр start указывает на начальную позицию поиска.  
Иногда необходимо сбросить состояние экземпляра Matchercв исходное, для этого применяется метод `reset()` или `reset(CharSequence input)`, который также устанавливает новую последовательность символов для поиска.  
Для замены всех подпоследовательностей символов, удовлетворяющих шаблону, на заданную строку можно применить метод `replaceAll(String replacement)`.  
В  регулярном выражении для  более удобной обработки входной последовательности применяются группы, которые помогают выделить части найденной подпоследовательности. В шаблоне они обозначаются скобками «(» и «)». Номера групп начинаются с единицы. Нулевая группа совпадает со всей найденной под последовательностью. Далее приведены методы для извлечения информации о группах.  
`String group()` — возвращает всю подпоследовательность, удовлетворяющую шаблону;  
`int start()` — возвращает индекс первого символа подпоследовательности, удовлетворяющей шаблону;  
`int start(int group)` — возвращает индекс первого символа указанной группы;  
`int end()` — возвращает индекс последнего символа подпоследовательности, удовлетворяющей шаблону;  
`int end(int group)` — возвращает индекс последнего символа указанной группы;  
`String group(int group)` — возвращает конкретную группу по позиции;  
boolean hitEnd() — возвращает истину, если был достигнут конец входной 
последовательности.  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html  
Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 178-179  
***
**Вопрос 42.**  
Что появится в консоли в результате работы фрагмента программы?  
``` java
System.out.println{"-1234".matches("-?\\d+"));
System. out. println ("5678". matches (" - ? \ \d+"));
System.out.println("+9ll".matches("-?\\d+"));
System.out.println("+911".matches("(-|\\+)?\\d+"));
```
Поясните ответ.  
**Ответ:**  
``` java
//если исправить начальную скобку, то true 	
//Error:() java: illegal escape character. если исправить, то true 	
false
true
```
Пояснение  
`System.out.println{"-1234".matches("-?\\d+"))` – ничего не будет выведено, т.к. используется неверное написание метода. Если исправить “}” на “(“, то проверяется наличие строки, содержащей одну или более цифр с “–“ вначале или без него.  
`System. out. println ("5678". matches (" - ? \ \d+"))` – ничего выведено не будет, т.к. возникает ошибка компиляции, сообщающая о неверно используемых пробельных символах. Если исправить, то проверяется точно тоже, что и в предыдущей строке  и будет выведено true.  
`System.out.println("+9ll".matches("-?\\d+"))` – будет выведено true, т.к. в заданной строке встречается одна цифра.  
`System.out.println("+911".matches("(-|\\+)?\\d+"))` - будет выведено true, т.к. в строке есть совпадение с шаблоном. В частности проверяется наличие строки, содержащей одну или более цифр с одним из символов “–“, “+” вначале или без них.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 178-179  
***
**Вопрос 43.**
Что появится в консоли в результате работы фрагмента программы?  
``` java
System.out.println(
	Arrays
	.toString("Then, when you have found the gold."
		.split("n\\W+")
	)
);
```
Поясните ответ.  
**Ответ:**  
``` java
[The, whe, you have found the gold.]
```
Пояснение: Прагмент кода `split("n\\W+")`, производит разбивку строки на элементы по шаблону `"n\\W+"`, который выбирает последовательности, начинающейся с `“n”` и включающие не менее одного раза все не словообразующие символы.  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 178-179  
***
**Вопрос 44.**  
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.  
**Ответ:**  
``` java
regex = "^[А-Z].*?\\."
```
Но желательно сделать отсечение крайних пробельных символов методом trim().  
**Источник:** Блинов, И.Н., Романчик, В. С. «Java. Методы программирования», с. 178-179  
***
**Вопрос 45.**  
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении  
"Then, when you have found the gold".  
**Ответ:**   
``` java
String str = "Then, when you have found the gold";
System.out.println(str.replaceAll("[aeiouy]","_"));
```
`// out`  
`Th_n, wh_n ___ h_v_ f__nd th_ g_ld`  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replaceAll-java.lang.String-java.lang.String-  
https://coderoad.ru/11810406/%D0%9A%D0%B0%D0%BA-%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B8%D1%82%D1%8C-%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B3%D0%BB%D0%B0%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%BC-%D0%B2-Java  
***
**Вопрос 46.**  
Определите, будет ли найдено в строке   
`"Java now has regular expressions"`  
совпадение для следующих выражений:  
``` java
^Java
\Breg.*
n.w\s+h(a|i)s
s?
s*
s+
S{4}
S{1}
S{0,3}
```
Поясните ответ.  
**Ответ:**    
`^Java` – да, т.к. именно так предложение и начинается  
`\Breg.*` - нет, \B указывает на поиск не на границе слова  
`n.w\s+h(a|i)s` – да, строка должна начинаться на “n”, следом любой символ, далее “w”, пробел один раз или более, “h”, потом ”a” или “i”  и заканчиваться на “s” (now has)  
`s?` – да, “s” один раз или ни разу  
`s*` -да, “s” ноль или более раз  
`s+` -да, все последовательности “s”  
`S{4}` – нет, прописных 4 “S” там нет  
`S{1}` - нет, прописной 1 “S” там тоже нет  
`S{0,3}` – нет, прописной “S” от 0 до 3 раз там также нет  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html  
***
**Вопрос 47.**  
Примените регулярное выражение  
`(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b`  
к строке  
`"Arline ate eight apples and one orange while Anita hadn't any"`
Поясните ответ.  
**Ответ:**  
``` java
Arline
 ate
 one
 orange
 Anita
 ```
Пояснение:   
`(?i)` – сопоставляет оставшуюся часть шаблона без учета регистра,  
`((^[aeiou])|(\s+[aeiou]))\w+?` – означает поиск с начала строки  последовательности, начинающейся с одного из символов “aeiou” или поиск последовательности начинающейся с любого кол-ва пробельных символов и одного из все тех же символов “aeiou”, включающей любой словообразующий символ до совпадения с оставшейся частью шаблона,  
`[aeiou]\b` – ищет последний символ слов соответствующий набору “aeiou”.  
В итоге выбираются слова без учета регистра с начала предложения начинающиеся и оканчивающиеся  на [aeiou].  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html  
***
**Вопрос 48.**  
Какие подстроки извлекают следующие регулярные выражения?  
``` java
[0-6]
[^n-p]
[A-Za-z0-9_]
\w
[A-C][n-p][a-c]
waz{3,5}up
[abc]+
.*
```
**Ответ:**  
`[0-6]` – цифры от 0 до 6  
`[^n-p]` – символы, исключая диапазон от "n" до "p"  
`[A-Za-z0-9_]` – словообразующие символы, аналог “\w”  
`\w` – словообразующие символы, аналог [A-Za-z0-9_]  
`[A-C][n-p][a-c]` – последовательность символов: заглавных от "A" до "C", строчных от "n" до "p", от "a" до "с"  
`waz{3,5}up` – последовательность, начинающаяся на “wa”, содержащая букву “z” от 3 до 5 раз и оканчивающаяся на “up”  
`[abc]+` - символы ”a”, ”b” и ”c”, повторяющиеся один и более раз  
`.*` - любой символ, повторяющийся любое кол-во раз, фактически вся строка.  
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html  
***
**Вопрос 49.**  
Сформируйте регулярное выражение, которое находит предложения, начинающиеся с "Input:" и заканчивающиеся на "successful".  
**Ответ:** 
``` java
regex = "Input:.*?successful"
```
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html  
***
**Вопрос 50**  
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте названия файлов (имя + расширение) графических форматов gif, png, jpg.  
**Ответ:** 
``` java
regex = "\\b[^\\s]*?\\.(jpe?g|png|gif)\\b"
```
**Источник:** https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html 
***
